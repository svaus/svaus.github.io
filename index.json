[
{
	"uri": "https://svaus.github.io/posts/reactdotenv/",
	"title": "Managing configuration in React App",
	"tags": [],
	"description": "",
	"content": "Coming soon..\n"
},
{
	"uri": "https://svaus.github.io/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://svaus.github.io/posts/dockerazpbuildagent/",
	"title": "Docker azure pipeline build agent",
	"tags": [],
	"description": "",
	"content": "Creating a docker build agent for azure pipeline is very easy. There are few simple steps. We will be using chocoletey to create this agent.\nOverall flow : graph TD A(\"Build Docker Image\") A--B(\"Push image Azure Container Registry\") B--C(\"Pull from Azure Container Registry\") C--D(\"Create Docker container instance\") D--E(\"Registers with Azure DevOps organisation\") \rFirstly create a Dockerfile where we can provide docker instructions. In this case I am using windows core 2019 image, but you can use any other images.\nFROMmcr.microsoft.com/windows/servercore:ltsc2019SHELL [\u0026#34;powershell\u0026#34;, \u0026#34;-Command\u0026#34;, \u0026#34;$ErrorActionPreference = \u0026#39;Stop\u0026#39;; $ProgressPreference = \u0026#39;SilentlyContinue\u0026#39;;\u0026#34;]WORKDIR/azpCOPY InstallChoco.ps1 .RUN .\\InstallChoco.ps1 COPY InstallDotNetCoreSdkChoco.ps1 .RUN .\\InstallDotNetCoreSdkChoco.ps1COPY start.ps1 .CMD powershell .\\start.ps1 Start from a base image it could be ltsc2019 or ltsc2016 or ubuntu image. Set Powershll as the shell command Set WORKDIR - working directory to azp or something of your choice Copy and run 3 powershell scripts InstallChoco.ps1 , InstallDotNetCoreSdkChoco.ps1 and start.ps1 using the COPY and RUN instruction of Dockerfile  Let us add the powershell scripts. Note that you can get latest powershell from microsoft docs https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/docker?view=azure-devops.\nSave the below content to start.ps1 file:\nif (-not (Test-Path Env:AZP_URL)) { Write-Error \u0026#34;error: missing AZP_URL environment variable\u0026#34; exit 1 } if (-not (Test-Path Env:AZP_TOKEN_FILE)) { if (-not (Test-Path Env:AZP_TOKEN)) { Write-Error \u0026#34;error: missing AZP_TOKEN environment variable\u0026#34; exit 1 } $Env:AZP_TOKEN_FILE = \u0026#34;\\azp\\.token\u0026#34; $Env:AZP_TOKEN | Out-File -FilePath $Env:AZP_TOKEN_FILE } Remove-Item Env:AZP_TOKEN if ($Env:AZP_WORK -and -not (Test-Path Env:AZP_WORK)) { New-Item $Env:AZP_WORK -ItemType directory | Out-Null } New-Item \u0026#34;\\azp\\agent\u0026#34; -ItemType directory | Out-Null # Let the agent ignore the token env variables $Env:VSO_AGENT_IGNORE = \u0026#34;AZP_TOKEN,AZP_TOKEN_FILE\u0026#34; Set-Location agent Write-Host \u0026#34;1. Determining matching Azure Pipelines agent...\u0026#34; -ForegroundColor Cyan $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(\u0026#34;:$(Get-Content ${Env:AZP_TOKEN_FILE})\u0026#34;)) $package = Invoke-RestMethod -Headers @{Authorization=(\u0026#34;Basic $base64AuthInfo\u0026#34;)} \u0026#34;$(${Env:AZP_URL})/_apis/distributedtask/packages/agent?platform=win-x64\u0026amp;`$top=1\u0026#34; $packageUrl = $package[0].Value.downloadUrl Write-Host $packageUrl Write-Host \u0026#34;2. Downloading and installing Azure Pipelines agent...\u0026#34; -ForegroundColor Cyan $wc = New-Object System.Net.WebClient $wc.DownloadFile($packageUrl, \u0026#34;$(Get-Location)\\agent.zip\u0026#34;) Expand-Archive -Path \u0026#34;agent.zip\u0026#34; -DestinationPath \u0026#34;\\azp\\agent\u0026#34; try { Write-Host \u0026#34;3. Configuring Azure Pipelines agent...\u0026#34; -ForegroundColor Cyan .\\config.cmd --unattended ` --agent \u0026#34;$(if (Test-Path Env:AZP_AGENT_NAME) { ${Env:AZP_AGENT_NAME} } else { ${Env:computername} })\u0026#34; ` --url \u0026#34;$(${Env:AZP_URL})\u0026#34; ` --auth PAT ` --token \u0026#34;$(Get-Content ${Env:AZP_TOKEN_FILE})\u0026#34; ` --pool \u0026#34;$(if (Test-Path Env:AZP_POOL) { ${Env:AZP_POOL} } else { \u0026#39;Default\u0026#39; })\u0026#34; ` --work \u0026#34;$(if (Test-Path Env:AZP_WORK) { ${Env:AZP_WORK} } else { \u0026#39;_work\u0026#39; })\u0026#34; ` --replace # remove the administrative token before accepting work Remove-Item $Env:AZP_TOKEN_FILE Write-Host \u0026#34;4. Running Azure Pipelines agent...\u0026#34; -ForegroundColor Cyan .\\run.cmd } finally { Write-Host \u0026#34;Cleanup. Removing Azure Pipelines agent...\u0026#34; -ForegroundColor Cyan .\\config.cmd remove --unattended ` --auth PAT ` --token \u0026#34;$(Get-Content ${Env:AZP_TOKEN_FILE})\u0026#34; } Create a new file named InstallChoco.ps1. This will be used to install choco in the docker images\n[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor \u0026#34;Tls12\u0026#34; Invoke-WebRequest -Uri \u0026#34;https://chocolatey.org/install.ps1\u0026#34; -Outfile \u0026#34;chocoinstall.ps1\u0026#34; .\\chocoinstall.ps1 choco config set cachelocation C:\\chococache Once choco is added, you can add any capability by simply installing it with choco. So let us add dotnet core sdk via choco. Create a file named InstallDotNetCoreSdkChoco.ps1 and add below code.\nchoco install dotnetcore-sdk -version 2.1.4 --confirm --limit-output choco install dotnetcore-sdk -version 2.1.7 --confirm --limit-output choco install dotnetcore-sdk -version 3.1.0 --confirm --limit-output Creating docker container for azp Build the docker images using docker build command.\ndocker build -t myazpagent:latest . Once this is done, you can easily create the docker container by running below command.\ndocker run -e AZP_URL=https://dev.azure.com/{username} -e AZP_TOKEN=$Env:AZP_TOKEN -e AZP_AGENT_NAME=$Env:AZP_Build_Agent_Name -e AZP_POOL=$Env:AZP_POOL myazpagent:latest Have fun !!\n"
},
{
	"uri": "https://svaus.github.io/posts/jobschedulerwithdotnetcore/",
	"title": "Job scheduler with dotnet core",
	"tags": [],
	"description": "",
	"content": "This is sample job scheduler with Topshelf, Autofac, Quartz, log4Net. Currently using DotNet Core 2.0 version\nThis repository implemetns a simple console application with following libraries\n Topshelf : For creating service Autofac : For dependency injection Quartz : For scheduling job, also uses xml based job configuration log4net : For logging  Installation Build the solution in release mode and copy to server directory. Open command prompt in the directory.\nRun below command :\nSampleJobSchedulerWithDotNetCore.exe install -username “DOMAIN\\Service Account” -password “Its A Secret” -servicename “SampleJobSchedulerWithDotNetCore” –autostart\nRepo You can find the repository here :\nhttps://github.com/svaus/SampleJobSchedulerWithDotNetCore\nCreate a dotnet core project. Add below packages by modifying csproj file or nuget package manager.\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Autofac\u0026quot; Version=\u0026quot;4.9.1\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Autofac.Extras.Quartz\u0026quot; Version=\u0026quot;4.4.0\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;log4net\u0026quot; Version=\u0026quot;2.0.8\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Quartz\u0026quot; Version=\u0026quot;3.0.7\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Quartz.Jobs\u0026quot; Version=\u0026quot;3.0.7\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Quartz.Plugins\u0026quot; Version=\u0026quot;3.0.7\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Topshelf\u0026quot; Version=\u0026quot;4.2.0\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Topshelf.Autofac\u0026quot; Version=\u0026quot;4.0.1\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Topshelf.Log4Net\u0026quot; Version=\u0026quot;4.2.0\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Topshelf.Quartz\u0026quot; Version=\u0026quot;0.4.0.1\u0026quot; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Modify Program.cs file and add below code. This code is doing following\n Adding Log4Net for logging to file Adding DI Initializing a HostFactory which sets windows service properties Configure Log4Net with Topself  namespace SampleJobSchedulerWithDotNetCore { class Program { static void Main(string[] args) { var logRepository = LogManager.GetRepository(Assembly.GetEntryAssembly()); XmlConfigurator.Configure(logRepository, new FileInfo(\u0026quot;log4net.config\u0026quot;)); IContainer container = DependencyInjection.Build(); HostFactory.Run(hostConfigurator =\u0026gt; { // Set windows service properties hostConfigurator.SetServiceName(\u0026quot;SampleSchedulerService\u0026quot;); hostConfigurator.SetDisplayName(\u0026quot;Sample Service\u0026quot;); hostConfigurator.SetDescription(\u0026quot;Executes Job.\u0026quot;); hostConfigurator.RunAsLocalSystem(); // Configure Log4Net with Topself hostConfigurator.UseLog4Net(); hostConfigurator.UseAutofacContainer(container); hostConfigurator.Service\u0026lt;SchedulerService\u0026gt;(serviceConfigurator =\u0026gt; { serviceConfigurator.ConstructUsing(hostSettings =\u0026gt; container.Resolve\u0026lt;SchedulerService\u0026gt;()); serviceConfigurator.WhenStarted(s =\u0026gt; s.Start()); serviceConfigurator.WhenStopped(s =\u0026gt; s.Shutdown()); }); }); } } } It is very simple to create a job scheduler with dotnet core Hostfactory. On compilation this will generate an exe file which can just be added as windows service.\n"
},
{
	"uri": "https://svaus.github.io/posts/gettingstarteddotnetcoreapi/",
	"title": "Dotnet Core Api with Serilog, Autofac, Swagger",
	"tags": [],
	"description": "",
	"content": "This blog post we will create a sample DotNet Core Api project with :\n Serilog implementation with various sinks console, file, application insigths Autofac Swagger with ReDoc and Material Design  Tools used  VS Code Aspnet Core 2.2 SDK Azure (For Application Insights only)  dotnet new webapi Add Serilog Logging to project Add below packages to solution/project\ndotnet add package Serilog.AspNetCore dotnet add package Serilog.Sinks.Console dotnet add package Serilog.Settings.Configuration Modify the Program.cs file as below. Added method UseSerilog which is injecting log configuration from configuration file i.e. appsettings.json\npublic static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) .UseStartup\u0026lt;Startup\u0026gt;() .UseSerilog((hostingContext, loggerConfiguration) =\u0026gt; { loggerConfiguration .ReadFrom .Configuration(hostingContext.Configuration) .Enrich.FromLogContext() .WriteTo.Console(); }); Now add the below section in appsettings.json file at root level of appsetting json :\n\u0026#34;Serilog\u0026#34;: { \u0026#34;Using\u0026#34;: [ \u0026#34;Serilog.Sinks.Console\u0026#34; ], \u0026#34;MinimumLevel\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;WriteTo\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;Console\u0026#34; } ], \u0026#34;Enrich\u0026#34;: [ \u0026#34;FromLogContext\u0026#34;, \u0026#34;WithMachineName\u0026#34;, \u0026#34;WithThreadId\u0026#34; ], \u0026#34;Properties\u0026#34;: { \u0026#34;Application\u0026#34;: \u0026#34;SampleDotNetCoreApi\u0026#34; } } In configure method of Startup.cs class add below code in the beginning and also inject ILoggerFactory. This ILoggerFactory is injected by AspNetCore dependency injection.\nloggerFactory.AddSerilog(); Add logging to Rolling File using Serilog If you want to do logging to file, Serilog provides sink for RollingFile.\ndotnet add package Serilog.Sinks.RollingFile And to appsettings.json file add the section for RollingFile. There is no code required for this. Serilog will read the configuration and apply the settings. The only thing which is required is adding the package.\n\u0026#34;WriteTo\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;Console\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;RollingFile\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;pathFormat\u0026#34;: \u0026#34;logs\\\\log-{Date}.txt\u0026#34;, \u0026#34;outputTemplate\u0026#34;: \u0026#34;{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level}] {Message}{NewLine}{Exception}\u0026#34;, } } ], Adding Application insight to Serilog Adding application insights with Serilog is just two steps as below :\ndotnet add package Serilog.Sinks.ApplicationInsights Also add the below configuration in appsettings.json. Change the instrumentation key.\n\u0026#34;WriteTo\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;Console\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;RollingFile\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;pathFormat\u0026#34;: \u0026#34;logs\\\\log-{Date}.txt\u0026#34;, \u0026#34;outputTemplate\u0026#34;: \u0026#34;{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level}] {Message}{NewLine}{Exception}\u0026#34;, } }, { \u0026#34;Name\u0026#34;: \u0026#34;ApplicationInsights\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;instrumentationKey\u0026#34;: \u0026#34;KEY\u0026#34;, \u0026#34;telemetryConverter\u0026#34;: \u0026#34;Serilog.Sinks.ApplicationInsights.Sinks.ApplicationInsights.TelemetryConverters.TraceTelemetryConverter, Serilog.Sinks.ApplicationInsights\u0026#34; } } ], Prefix for Development APM Prefix is a free tool provided for development environment monitoring. Download the tool from below location\nPrefix Download\nOnce downloaded install the tool in the development machine.\nWhy add Autofac Aspnet Core comes up with default dependency injection hence third party dependency injection is not required. However, default dependency injection doesn\u0026rsquo;t have full functionality as offered by other DI libraries. Autofac is another DI library with lot of features built into it.\nAdd Autofac Insatall the package using below command. I am going to use without configure container method as usually in complex project we would need a lot of customisation and without configure container works in that scenario.\ndotnet add package Autofac.Extensions.DependencyInjection For more details about Autofac check the documentation here -\u0026gt; Autofac\nAdd a public property in the Startup.cs\npublic IContainer ApplicationContainer { get; private set; } and add the below lines of code in ConfigureServices method and change the return type from void to IServiceProvider which will be replaced by new AutofacServiceProvider. This registers all the dependencies in that service to Autofac :\nvar builder = new ContainerBuilder(); builder.Populate(services); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(ApplicationContainer); Add Swagger/Swashbuckle to API for documentation dotnet add package Swashbuckle.AspNetCore Add the below lines of code in ConfigureService method\nservices.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new Info{ Title = \u0026#34;Sample DotNet Core Api\u0026#34;, Version = \u0026#34;v1\u0026#34; }); }); Add below lines in Configure method :\napp.UseSwagger(); app.UseSwaggerUI(c=\u0026gt; { c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Sample DotNet Api V1\u0026#34;); c.RoutePrefix = string.Empty; }); Adding ReDoc for swagger for different UI theme dotnet add package Swashbuckle.AspNetCore.ReDoc Add below code and comment out UseSwaggerUI piece of code\n// app.UseSwaggerUI(c=\u0026gt; {  // c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Sample DotNet Api V1\u0026#34;);  // c.RoutePrefix = string.Empty;  // c.InjectStylesheet(\u0026#34;/swagger-ui/custom.css\u0026#34;);  // });  app.UseReDoc(c =\u0026gt; { c.SpecUrl = \u0026#34;/swagger/v1/swagger.json\u0026#34;; c.DocumentTitle = \u0026#34;Sample DotNet Core Api V1\u0026#34;; }); Add another custom style Updated the custom.css for material design UI\n"
},
{
	"uri": "https://svaus.github.io/about/",
	"title": "About Me",
	"tags": [],
	"description": "",
	"content": "A coder.\n"
},
{
	"uri": "https://svaus.github.io/",
	"title": "Blogs for dotnet, azure and devops",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://svaus.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://svaus.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]